<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-06-07T18:17:23.8588871"><title>Shape.js | Instance</title><script type="application/json" id="virtual-toc-data">[]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Shape.js | Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/shape-js.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Shape.js | Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/shape-js.html#webpage",
    "url": "writerside-documentation/shape-js.html",
    "name": "Shape.js | Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Instance Help"
}</script><!-- End Schema.org --></head><body data-id="Shape-js" data-main-title="Shape.js" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Shape-js" id="Shape-js.md">Shape.js</h1><p id="i3mxjkx_28">Dit stukje code definieert een JavaScript object genaamd Shape, dat verschillende basis berekeningen bevat. Laten we eens kijken naar elk van de methoden:</p><p id="i3mxjkx_29">De functie <code class="code" id="i3mxjkx_30">intersectRay()</code> bepaalt het snijpunt tussen een straal en een vorm. Eerst berekent het de hoek van de straal en past het vervolgens iets aan om precisieproblemen te vermijden. Vervolgens doorloopt het elke rand van de vorm en controleert of de straal ermee snijdt. Als er een snijpunt wordt gevonden, slaat het het snijpunt en de normalen (loodrechte richtingen) op dat punt op. Na het vinden van alle snijpunten, identificeert het het dichtstbijzijnde snijpunt ten opzichte van het startpunt van de straal en stuurt informatie hierover, inclusief het snijpunt, de vorm en de normaal op dat punt.</p><p id="i3mxjkx_31">De functie <code class="code" id="i3mxjkx_32">contains()</code> controleert of een gegeven punt <code class="code" id="i3mxjkx_33">(mx, my)</code> zich binnen een veelhoek bevindt die wordt gedefinieerd door een array (een lijst als het ware) van punten. Het maakt gebruik van het ray casting-algoritme, waarbij een straal wordt uitgezonden vanaf het gegeven punt en wordt geteld hoe vaak deze de randen van de veelhoek kruist. Als het aantal kruisingen oneven is, ligt het punt binnen de veelhoek; anders ligt het buiten.</p><p id="i3mxjkx_34">Deze code wordt gebruikt als basis voor alle andere vormen, dus de <code class="code" id="i3mxjkx_35">Circle.js</code>, <code class="code" id="i3mxjkx_36">Line.js</code>, <code class="code" id="i3mxjkx_37">Rectangle.js</code> &amp; <code class="code" id="i3mxjkx_38">Triangle.js</code> zijn allemaal opgebouwd met deze code als basis en krijgen de vorm door een aantal punt te defini&euml;ren, dit scheelt weer code en zorgt voor een soepeler gebruik tussen meerdere vormen</p><div class="code-block" data-lang="javascript">
Shape.prototype.intersectRay = function(ray, shape) {
    //ray
    const angleRadians = Math.atan2(ray.to.y - ray.from.y, ray.to.x - ray.from.x);
    const tinyMovement = 0.1; // Define a very small movement value
    const x1 = ray.from.x + tinyMovement * Math.cos(angleRadians); // Move x1 slightly closer to x2
    const y1 = ray.from.y + tinyMovement * Math.sin(angleRadians); // Move y1 slightly closer to y2
    const x2 = ray.to.x;
    const y2 = ray.to.y;


    //shape
    const points = shape.points;
    const n = points.length;

    let intersections = [];

    if (n &gt; 2) {
        //loop through all the edges
        let _x1, _y1, _x2, _y2,
            _x3, _y3, _x4, _y4;

        for (let i = 0; i &lt; n; i++) {
            _x1 = points[i].x;
            _y1 = points[i].y;
            _x2 = points[(i + 1) % n].x;
            _y2 = points[(i + 1) % n].y;

            _x3 = x1;
            _y3 = y1;
            _x4 = x2;
            _y4 = y2;

            const intersection = VectorIntersectsVector(_x1, _y1, _x2, _y2, _x3, _y3, _x4, _y4);
            if (intersection) intersections.push(intersection);
        }
    }

    if (n === 2) {
        //loop through all the edges
        let _x1, _y1, _x2, _y2,
            _x3, _y3, _x4, _y4;

        _x1 = points[0].x;
        _y1 = points[0].y;
        _x2 = points[1].x;
        _y2 = points[1].y;

        _x3 = x1;
        _y3 = y1;
        _x4 = x2;
        _y4 = y2;

        const intersection = VectorIntersectsVector(_x1, _y1, _x2, _y2, _x3, _y3, _x4, _y4);
        if (intersection) intersections.push(intersection);
    }

    if (intersections.length === 0) {
        return;
    }

    let closestIntersection = null;
    let closestDistance = 10000;

    intersections.forEach((intersection) =&gt; {
        const distance = Math.sqrt(Math.pow(intersection.x - x1, 2) + Math.pow(intersection.y - y1, 2));
        if (distance &lt; closestDistance) {
            closestIntersection = intersection;
            closestDistance = distance;
        }
    });

    //get the of the ray from [closestIntersection] to [from]
    const angleOfRay = normalizeDegreeAngle(RadiansToDegrees(Math.atan2(y1 - closestIntersection.y, x1 - closestIntersection.x)));
    const normal1 = normalizeDegreeAngle(closestIntersection.normals[0]);
    const normal2 = normalizeDegreeAngle(closestIntersection.normals[1]);

    //check which is closer and set closestIntersection.normals to that
    if (getClosestNumber(angleOfRay, [normal1, normal2]) === normal1) {
        closestIntersection.normals = normal1;
    } else {
        closestIntersection.normals = normal2;
    }

    //check if the ray is hitting the shape from the inside


    return {
        from: {
            x: x1,
            y: y1
        },
        to: {
            x: closestIntersection.x,
            y: closestIntersection.y
        },
        shape: shape,
        normal: closestIntersection.normals
    };

    function VectorIntersectsVector(x1, y1, x2, y2, x3, y3, x4, y4) {
        const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (den === 0) {
            return;
        }

        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

        const angleDegrees1 = RadiansToDegrees(Math.atan2(y2 - y1, x2 - x1)) + 90;
        const angleDegrees2 = RadiansToDegrees(Math.atan2(y2 - y1, x2 - x1)) - 90;


        if (t &gt;= 0 &amp;&amp; t &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1) {
            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1),
                normals: [
                    angleDegrees1,
                    angleDegrees2
                ]
            };
        }
    }
}

Shape.prototype.contains = function(mx, my) {
    // Check if a point (mx, my) is inside a polygon defined by an array of points
    const points = this.points;

    let isInside = false;
    const n = points.length;

    for (let i = 0, j = n - 1; i &lt; n; j = i++) {
        const xi = points[i].x;
        const yi = points[i].y;
        const xj = points[j].x;
        const yj = points[j].y;

        const intersect =
            ((yi &gt; my) !== (yj &gt; my)) &amp;&amp;
            (mx &lt; (xj - xi) * (my - yi) / (yj - yi) + xi);

        if (intersect) {
            isInside = !isInside;
        }
    }

    return isInside;
}
</div><div class="last-modified">Last modified: 07 juni 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="rectangle-js.html" class="navigation-links__next">Rectangle.js</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>